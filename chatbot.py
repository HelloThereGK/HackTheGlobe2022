# -*- coding: utf-8 -*-
"""chatbotv2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lJ8c18PcXdcKDWtsafCCx8TbCGxEQhvT
"""

!pip install tensorflow_text

import numpy as np
import tensorflow as tf
import nltk
#nltk.download('punkt')
import pandas as pd
import json
import tensorflow_text as text 
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.layers import Input, Embedding, LSTM , Dense,GlobalMaxPooling1D,Flatten
from tensorflow.keras.models import Model
import matplotlib.pyplot as plt
import string

with open("/content/intents.json") as file:
  data = json.load(file)

tags = []
patterns = []
responses = {}
for intent in data['intents']:
  responses[intent['tag']] = intent['responses']
  for lines in intent['patterns']:
    patterns.append(lines)
    tags.append(intent['tag'])

data = pd.DataFrame({"patterns":patterns,"tags":tags})
print(patterns)

import string

pat1 = []
for i in patterns:
  pat1.append(i.translate(str.maketrans('', '', string.punctuation)).lower())
pat1
pat2 = ' '.join(pat1)
pat2

data['patterns'] = data['patterns'].apply(lambda wrd:[ltrs.lower() for ltrs in wrd if ltrs not in string.punctuation])
data['patterns'] = data['patterns'].apply(lambda wrd: ''.join(wrd))

tokenizer = Tokenizer(num_words=2000)
tokenizer.fit_on_texts(data['patterns'])
train = tokenizer.texts_to_sequences(data['patterns'])

from tensorflow.keras.preprocessing.sequence import pad_sequences

x_train = pad_sequences(train)

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
y_train = le.fit_transform(data['tags'])

input_shape = x_train.shape[1]


vocabulary = len(tokenizer.word_index)

output_length = le.classes_.shape[0]

#creating the model
i = Input(shape=(input_shape,))
x = Embedding(vocabulary+1,10)(i)
x = LSTM(10,return_sequences=True)(x)
x = Flatten()(x)
x = Dense(output_length,activation="softmax")(x)
model  = Model(i,x)
#compiling the model
model.compile(loss="sparse_categorical_crossentropy",optimizer='adam',metrics=['accuracy'])
#training the model
train = model.fit(x_train,y_train,epochs=200)

!pip install geocoder
!pip install phonenumbers

import math



def haverside(lat1, lng1, lat2, lng2):
    """Calculate Haverside distance between two points: https://en.wikipedia.org/wiki/Haversine_formula"""
    k = math.pi/180
    R = 6371 #radius of the earth in km
    h = 0.5*(1-math.cos(k*(lat2-lat1)))+(math.cos(k*lat1)*math.cos(k*lat2)*(0.5*(1-math.cos(k*(lng2-lng1)))))
    distance = 2*R*math.asin(math.sqrt(h))
    return distance


def find_closest(data, mylocation):
    """Find the nearest location from a list of lat long data, as compared to your current location"""
    return min(data, key=lambda p: haverside(mylocation['lat'],mylocation['lon'],p['lat'],p['lon']))


#test out the haverside thing
testdata = [{'lat': 40, 'lon': -85},
                {'lat': 22.5,  'lon': -86 },
                {'lat': 39, 'lon': -86.1}]

mylocation = {'lat': 39, 'lon': -84}
print(find_closest(testdata, mylocation))

model.save_weights("chatbot.h5")

import geocoder
#print out my actual location from ip address
g = geocoder.ip('me')
print(g.latlng)

import phonenumbers
from phonenumbers import geocoder

#print out my actual location from phone my phone
test_number = "+16475519682"
p = phonenumbers.parse(test_number)
location = geocoder.description_for_number(p, "en")
print(location)

import requests
import pandas as pd
API_KEY = 'AIzaSyAozPC61aDIVteSpcw5x3OJSnhsiaG_yY0'


lat = 43.6609
lng = -79.3959
radius_toronto = 630000 #meters
# proxy type ideas: library, secondary_school, university
def getClosest(lat,lng):
  url2 = "https://maps.googleapis.com/maps/api/place/nearbysearch/json?location="+ str(lat)+"%2C"+str(lng)+"&rankby=distance&keyword=charity&key=AIzaSyAozPC61aDIVteSpcw5x3OJSnhsiaG_yY0"
  payload={}
  headers = {}

  response = requests.request("GET", url2, headers=headers, data=payload)
  data = pd.DataFrame(columns = ["name", "lat", "lng", "hours", "opennow", "vicinity", "intersection", "haverside"])
  #print(data["latitude"])
  #print(data)
  #print(response.json()['results'])
  latitudes = []
  longitudes = []
  names = []
  opennow = []
  vicinity = []
  intersections= []
  for result in (response.json()['results']):
    lat= result["geometry"]["location"]["lat"]
    lng = result["geometry"]["location"]["lng"]
    latitudes.append((result["geometry"]["location"]["lat"]))
    longitudes.append((result["geometry"]["location"]["lng"]))
    names.append((result["name"]))
    try:
      opennow.append((result["opening_hours"]["open_now"]))
    except KeyError:
      opennow.append("NaN")
    vicinity.append(result["vicinity"])
    url = "https://maps.googleapis.com/maps/api/place/nearbysearch/json?location="+ str(lat)+"%2C"+str(lng)+"&radius=100000&type=transit_station&key=AIzaSyAozPC61aDIVteSpcw5x3OJSnhsiaG_yY0"
    payload={}
    headers = {}
    response2 = requests.request("GET", url, headers=headers, data=payload)
    i=0
    for intersection_res in (response2.json()['results']):

      if (" at " in intersection_res['name']):
        intersections.append(intersection_res['name'])
        break
      if i == 19:
        intersections.append("NaN")
      i+=1


  data["lat"] = latitudes
  data["lng"] = longitudes
  data["name"] = names
  data["opennow"] = opennow
  data["vicinity"] = vicinity
  data["intersection"] = intersections
  return data
    # return (data["name"][0:3],data["vicinity"][0:3],data["intersection"][0:3],data["opennow"][0:3])

print(data)

!pip install geopandas
!pip install geopy

API_KEY = 'AIzaSyAozPC61aDIVteSpcw5x3OJSnhsiaG_yY0'
def findLtLn(address):
  address = address.replace(" ", "+")
  


  # address = address.translate(str.maketrans('', '', string.punctuation))
  try:
    response = requests.get('https://maps.googleapis.com/maps/api/geocode/json?address='+address+',+Toronto,+ON&key=AIzaSyAozPC61aDIVteSpcw5x3OJSnhsiaG_yY0')
  except:
    return -1
  resp_json_payload = response.json()
# print(response.json())
  retval = resp_json_payload['results'][0]['geometry']['location']
  lat = retval['lat']
  lng = retval['lng']
  return [lat, lng]

findLtLn(" 240 McCaul St ")[0]

distVals = getClosest(lat,lng)

distVals["name"][0]

#chatting
import random
roboName = "YPOP"
diffLoc = False
addrVal = ""
wordDict = []
locKnown = False
firstBoot = True 
locFormat = True
lat = 43.6609
lng = -79.3959
while True:
  if firstBoot:
    print("Hi, I'm "+roboName+". I'm here to help you find menstrual product pickup centres near you.") 
    firstBoot = False
  if(locKnown == False and diffLoc == False):
    print("Can I use your location to identify the closest pickup centres? \n Type 'Y' for Yes, 'N' for No.")
  texts_p = []
  prediction_input = input('You : ')
  if(prediction_input == 'FAQ'):
    print("Q: How long does a period last? \n A: 3-8 days. They reoccur every 28 days. ")
    print("Q: How much blood will I lose? \n A: 4 tablespoons (60 mL)")
    print("Q: Should I flush my used pad down the toilet? \n A: Wrap it in the packaging and place in the disposal box.")
    print("Q: Can my tampon get lost inside of me? \n A: No. It's not possible.")
    print("Q: What if my period is late? \n A: This can occur due to many factors: stress, illness, pregnancy, etc. Check in with your doctor.")
    print("Q: Can I go for a swim? \n A: Yes. You can wear a tampon.")
    print("Q: What if my tampon feels uncomfortable? \n A: You should not be able to feel anything. Try adjusting its position.")
  if(prediction_input.lower() == 'more'):
    print("Here is information for the second closest pick up centre near you: ")
    print("Name: ",distVals['name'][1])
    print("Address: ",distVals['vicinity'][1])
    print("Major Intersection: ",distVals['intersection'][1])
    if(distVals['opennow'][1] != "NaN"):
      if(distVals['opennow'][1] == True):
        print("The location is currently open")
      else:
        print("The location is currently closed")
    continue
  if(locFormat == False):
    print("Sorry, the location you provided is not valid. Please try again. Enter the address in the following format: '120 Baker Street' ")
    continue
  if(prediction_input.lower() == 'y' and locKnown == False):
    print("Got it, using your current location. This is the pickup centre closest to you: ")
    locKnown = True
    distVals = getClosest(lat,lng)
    print("Name: ",distVals['name'][0])
    print("Address: ",distVals['vicinity'][0])
    print("Major Intersection: ",distVals['intersection'][0])
    if(distVals['opennow'][0] != "NaN"):
      if(distVals['opennow'][0] == True):
        print("The location is currently open")
      else:
        print("The location is currently closed")
    print("Type 'MORE' if you would like to see information for the second closest location to you.")
    print("Or, type 'FAQ' if you would like to see answers to frequently asked questions about menstrual health.")
    continue
  elif(prediction_input.lower() == 'n' and locKnown == False):
    print("Got it. Please enter the location you would like to find pick up centers closest to in the following format - '120 Baker Street': ")
    diffLoc = True
    continue 
  if(diffLoc):
    addrVal = prediction_input
    locVals = findLtLn(addrVal)
    lat = locVals[0]
    lng = locVals[1]
    if (locVals == -1):
      locFormat = False
      continue
    locKnown = True
    print("Got it, using the location you inputted. This is the closest pickup centre: ")
    distVals = getClosest(lat,lng)
    print("Name: ",distVals['name'][0])
    print("Address: ",distVals['vicinity'][0])
    print("Major Intersection: ",distVals['intersection'][0])
    if(distVals['opennow'][0] != "NaN"):
      if(distVals['opennow'][0] == True):
        print("The location is currently open")
      else:
        print("The location is currently closed")
    print("Type 'MORE' if you would like to see information for the second closest location to you.")
    print("Or, type 'FAQ' if you would like to see answers to frequently asked questions about menstrual health.")

    continue
  elif ( (not (prediction_input.lower() in pat2)) or (locKnown == False and (prediction_input.lower() != 'y' or prediction_input.lower() != 'n'))):
    print("Sorry, I don't understand what you just said. Try asking me to find the closest menstrual product pick-up center to you, or answering the prompt in the expected format.")
    continue
 
 
  
  #removing punctuation and converting to lowercase
  prediction_input = [letters.lower() for letters in prediction_input if letters not in string.punctuation]
  prediction_input = ''.join(prediction_input)
  texts_p.append(prediction_input)
  #tokenizing and padding
  prediction_input = tokenizer.texts_to_sequences(texts_p)
  prediction_input = np.array(prediction_input).reshape(-1)
  prediction_input = pad_sequences([prediction_input],input_shape)
  #getting output from model
  output = model.predict(prediction_input)
  output = output.argmax()
  

  #finding the right tag and predicting
  response_tag = le.inverse_transform([output])[0]
  print(random.choice(responses[response_tag]))
  if (response_tag == "FindLocation"):
    distVals = getClosest(lat,lng)
    print("Name: ",distVals['name'][0])
    print("Address: ",distVals['vicinity'][0])
    print("Major Intersection: ",distVals['intersection'][0])
    if(distVals['opennow'][0] != "NaN"):
      if(distVals['opennow'][0] == True):
        print("The location is currently open")
      else:
        print("The location is currently closed")
    print("Type 'MORE' if you would like to see information for the second and third closest locations to you.")
    print("Or, type 'FAQ' if you would like to see answers to frequently asked questions about menstrual health.")
    #ADD CODE FOR PRINTING LOCATION DATA 
  elif response_tag == "goodbye":
    break
  elif response_tag == 'opentoday':
    continue
    #ADD CODE FOR PRINTING OPEN HOURS FOR NEAREST LOCATION
    #PRINT IF IS OPEN

!pip install twilio

import os
from twilio.rest import Client

account_sid =""
auth_token = ""

client = Client(account_sid, auth_token)

client.messages.create(
    to="PHONE NUMBER",
    from_="twilioPhone",
    body = "insert text to send"
)

!pip install flask

from flask import Flask, request, redirect
from twilio.twiml.messaging_response import messaging_response

app = Flask(__name__)

@app.route("/sms",methods = ['GET','POST'])
def sms_reply():
  resp = MessagingResponse()
  resp.message("Test message")
  return str(resp)

if __name__ == "__main__":
  app.run(debug=True)

